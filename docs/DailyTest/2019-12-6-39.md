---
title: 每日练题#39
date: 2019-12-6
sidebar: auto
sidebarDepth: 2
tags: 
  - DailyTest
categories:
  - DailyTest
---

欢迎回来！ :smile:

这里是每日练题系列。 

这个系列会先分享昨天问题的答案并提出新的问题。

<!-- more -->

## 回顾上期

上期我们提出的问题是：

:star: **请你谈谈 JavaScript 中 V8 引擎的垃圾回收机制**

## 答案公布

![JS垃圾回收](https://blog-img-1252360401.cos.ap-guangzhou.myqcloud.com/20191206-1.jpg)

要了解清楚 JS 中的垃圾回收机制，

首先我们需要明确为什么需要垃圾回收机制。

### 为什么需要 :flags:

垃圾回收的原因很明确，

就是内存不够用了，

需要释放一些无用的占用来进行新的工作。

`V8` 只能使用系统的一部分内存，

> 具体来说在 64 位系统下是 1.4G，在 32 位系统下是 0.7G。

对于管理内存的方面我们后面继续讲解，

接着我们先聊聊 `垃圾` 这个概念是怎么被判断出来的，

也即是如何判断可以回收。

### 回收判断 :flags:

一般而言，我们的判断是否可回收的算法主要分为 `标记清除法` 和 `引用计数法` 两种。

**:star: 标记清除法**

这个方法的基本思路是，

- :one: 变量进入环境时将这个变量标记为 '进入环境'
- :two: 当变量离开环境时，将其标记为 '离开环境'

一般我们不应该清除运行中的变量的内存，

这可能会影响到应用的正常执行。

这里的 `标记清除法` 只是一个基本思路，

具体的实现方法各个 WEB 引擎的实现策略各有千秋，

我们这里展示使用比较广泛的策略：

- :one: 垃圾收集器在运行的时候给存储在内存中的所有变量都加上标记
- :two: 去掉环境中的变量以及被环境中变量所引用的变量的标记
- :three: 取出依然拥有标记的变量
- :four: 销毁带标记的值并释放对应的内存空间

目前使用该策略的有 IE、Firefox、Opera、Chrome 和 Safari，

但它们的具体实现仍然有很大的不同，

感兴趣的话可以继续深入研究。

![标记清除法](https://blog-img-1252360401.cos.ap-guangzhou.myqcloud.com/20191206-2.jpg)

**:star: 引用计数法**

`引用计数法` 是一种古老的思路，

曾是 IE 等一众浏览器使用的主流思路，

虽然这种方法已过时，

但它的思路仍有值得我们借鉴的地方。

这个方法的思路是：

跟踪记录每个值被引用的次数，

并以此为根据作为是否清除的依据。

举个栗子：

我们声明了一个变量 `a` 并将一个函数 `f()` 赋值给它，

此时 `f()` 的引用次数就是 1，

假如我们再把 `f()` 赋值给另一个变量 `b`，

这样 `f()` 的引用次数就变为 2 了。

直到 f() 的引用次数变为 0 时，

说明没有办法访问这个值了，

可以将其占用的内存空间回收回来。

早期使用这一方法的浏览器很快遇到了一个大问题： `循环引用`。

假设我们将 `f()` 赋值成如下这般：

``` javascript
function f() {
    var a = new Object();
    var b = new Object();

    a.hello = b;
    b.hello = a;
} 
```
这种情况下因为 `a` 跟 `b` 同时有各自属性的引用，

所以即便函数执行完毕依旧不会被清除。

别以为这种代码离我们有多远，

我们时刻都在写着这种代码，

来看下面一个例子：

``` javascript
// 循环引用例子
var el = document.getElementById('app');
el.onClick = function() { //... };

// 可以通过手动置空避免
window.onbeforeunload = function() {
    el = null;
}
```

![引用计数法](https://blog-img-1252360401.cos.ap-guangzhou.myqcloud.com/20191206-3.jpg)

### V8 回收策略 :flags:

`V8` 作为现代 WEB 内核之大成者，

![分代内存分配法](https://blog-img-1252360401.cos.ap-guangzhou.myqcloud.com/20191206-4.jpg)

使用的是一种博取众家所长的方法： `分代内存分配法`

顾名思义我们可以这么理解：

- :star: 新生代内存： 临时分配的内存，存活时间短。（64 位： 32 MB，32 位： 16 MB）
- :star: 老生代内存： 常驻的内存，存活时间长。

分好内存种类之后，

V8 对于这两种内存有着不同的回收策略，

以进行针对性的优化。

### 新生代内存 :flags:

**新生代内存**

![新生代内存](https://blog-img-1252360401.cos.ap-guangzhou.myqcloud.com/20191206-5.jpg)

对于新生代内存，

首先将其一分为二。

然后进行垃圾回收过程：

- :one: 将 `From` 对象检查一遍，如果对象存活则复制到 `To` 中（按顺序从头放置），如果对象非存活则直接回收。
- :two: `From` 循环一遍过后，原 `From` 和 `To` 两者 `角色对调`，并重复上述过程。

这么处理的很大的原因是为了处理如下的内存分布场景：

![内存零散](https://blog-img-1252360401.cos.ap-guangzhou.myqcloud.com/20191206-6.jpg)

橙色方块代表存活对象，白色代表待分配内存，

其实指的就是我们在 `操作系统` 一门课中学过的 `内存碎片`。

`V8` 使用 `Scavenge算法` 解决内存碎片问题，

解决后的空间分布就是下面这个样子的：

![内存分配完成情况](https://blog-img-1252360401.cos.ap-guangzhou.myqcloud.com/20191206-7.jpg)

有关于 `Scavenge算法` 更详细可以参考这里 [传送门](https://juejin.im/post/5b1f7e62e51d45068a6cb98f)

### 老生代内存 :flags:

**老生代内存**

如果 `新生代内存` 中的变量经过 `多次回收` 后仍然存在，

那么就会被放到 `老生代内存` 中，

这种情况被称为 `晋升`。

::: tip
其他发生 `晋升` 的条件还有:one:已经经历过一次 `Scavenge` 回收。:two: To 空间的内存占用超过 25%。
:::

对于 `老生代内存` 而言，

一般占用的内存要比 `新生代内存` 要大得多，

继续使用 `Scavenge算法` 显然是不现实的。

所以对于 `老生代内存` 而言使用的是两步走的算法：

- :star: 先使用 `标记清除法`。
- :star: 整理内存碎片，将存活对象全部往一端靠拢。（极其耗时）

![老生代内存](https://blog-img-1252360401.cos.ap-guangzhou.myqcloud.com/20191206-8.jpg)

### 运行优化 :flags:

上面我们提到 `老生代内存` 管理的最后一步极其耗时，

由于 `JavaScript` 使用的是单线程机制，

垃圾回收难免会影响到正常业务逻辑的执行，

`V8` 在此处采用增量标记的方法，

通俗点说就是把所有要执行的任务 `分成很多的小块间歇执行`。

想要详细了解的童鞋可以看这篇文章 [V8增量回收三色标记法](https://malcolmyu.github.io/2019/07/07/Tri-Color-Marking/)

### 参考资料 :flags:

- https://juejin.im/post/5ad3f1156fb9a028b86e78be
- https://juejin.im/post/5dd8b3a851882572f56b578f?utm_source=gold_browser_extension#heading-1
- https://juejin.im/post/5b1f7e62e51d45068a6cb98f
- https://malcolmyu.github.io/2019/07/07/Tri-Color-Marking/


## 提问

讲解完了昨天的问题，又到了今天的提问环节啦~

### 背景 :flags:

上面我们介绍了 `V8` 的垃圾回收原理，

既然已经进入了这个话题了，

那我们就继续深入下去吧！

### 今日提问 :flags:

“缥缈危楼紫翠间，良辰乐事古难全。”

---

**今天的问题是：**

:star: **请你谈谈 V8 执行 JavaScript 代码的流程**